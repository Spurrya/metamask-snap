{"version":3,"file":"siwe.js","sourceRoot":"","sources":["../src/siwe.ts"],"names":[],"mappings":";;;AAAA,uDAAsD;AACtD,qDAAgD;AAChD,qCAA6D;AAE7D,MAAM,GAAG,GAAG,IAAA,2BAAkB,EAAC,sBAAa,EAAE,aAAa,CAAC,CAAC;AAE7D;;;;;GAKG;AACH,SAAS,cAAc,CAAC,GAAW;IACjC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,IAAA,+BAAa,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;AACjD,CAAC;AAED;;;;;GAKG;AACH,SAAS,YAAY,CAAC,GAAW;IAC/B,IAAI;QACF,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC;QACrC,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC1C,OAAO,IAAI,CAAC,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;KACzD;IAAC,OAAO,CAAC,EAAE;QACV,GAAG,CAAC,CAAC,CAAC,CAAC;QACP,OAAO,GAAG,CAAC;KACZ;AACH,CAAC;AAaD;;;;;;;;;;GAUG;AACI,MAAM,UAAU,GAAG,CAAC,SAA2B,EAAe,EAAE;IACrE,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,GAAG,SAAS,CAAC;QAC3B,MAAM,OAAO,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QACnC,MAAM,aAAa,GAAG,IAAI,2BAAa,CAAC,OAAO,CAAC,CAAC;QAEjD,OAAO;YACL,aAAa,EAAE,IAAI;YACnB,aAAa;SACd,CAAC;KACH;IAAC,OAAO,KAAK,EAAE;QACd,8CAA8C;QAC9C,OAAO;YACL,aAAa,EAAE,KAAK;YACpB,aAAa,EAAE,IAAI;SACpB,CAAC;KACH;AACH,CAAC,CAAC;AAjBW,QAAA,UAAU,cAiBrB","sourcesContent":["import { ParsedMessage } from '@spruceid/siwe-parser';\nimport { isHexPrefixed } from 'ethereumjs-util';\nimport { projectLogger, createModuleLogger } from './logger';\n\nconst log = createModuleLogger(projectLogger, 'detect-siwe');\n\n/**\n * This function strips the hex prefix from a string if it has one.\n *\n * @param str - The string to check\n * @returns The string without the hex prefix\n */\nfunction stripHexPrefix(str: string) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str;\n}\n\n/**\n * This function converts a hex string to text if it's not a 32 byte hex string.\n *\n * @param hex - The hex string to convert to text\n * @returns The text representation of the hex string\n */\nfunction msgHexToText(hex: string): string {\n  try {\n    const stripped = stripHexPrefix(hex);\n    const buff = Buffer.from(stripped, 'hex');\n    return buff.length === 32 ? hex : buff.toString('utf8');\n  } catch (e) {\n    log(e);\n    return hex;\n  }\n}\n\n/**\n * A locally defined object used to provide data to identify a Sign-In With Ethereum (SIWE)(EIP-4361) message and provide the parsed message\n *\n * @typedef localSIWEObject\n * @param {boolean} isSIWEMessage - Does the intercepted message conform to the SIWE specification?\n * @param {ParsedMessage} parsedMessage - The data parsed out of the message\n */\nexport type SIWEMessage =\n  | { isSIWEMessage: true; parsedMessage: ParsedMessage }\n  | { isSIWEMessage: false; parsedMessage: null };\n\n/**\n * This function intercepts a sign message, detects if it's a\n * Sign-In With Ethereum (SIWE)(EIP-4361) message, and returns an object with\n * relevant SIWE data.\n *\n * {@see {@link https://eips.ethereum.org/EIPS/eip-4361}}\n *\n * @param msgParams - The params of the message to sign\n * @param msgParams.data - The data of the message to sign\n * @returns An object with the relevant SIWE data\n */\nexport const detectSIWE = (msgParams: { data: string }): SIWEMessage => {\n  try {\n    const { data } = msgParams;\n    const message = msgHexToText(data);\n    const parsedMessage = new ParsedMessage(message);\n\n    return {\n      isSIWEMessage: true,\n      parsedMessage,\n    };\n  } catch (error) {\n    // ignore error, it's not a valid SIWE message\n    return {\n      isSIWEMessage: false,\n      parsedMessage: null,\n    };\n  }\n};\n"]}